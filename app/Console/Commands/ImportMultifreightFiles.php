<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Str;

class ImportMultifreightFiles extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'ifs:import-multifreight-files {--reprocess-month=}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Reads files generated by Multifreight and imports data to corresponding MF tables';

    /**
     * The SFTP directory that DHL upload invoice files.
     *
     * @var string
     */
    protected $directory = '/home/scs/dump/';

    /**
     * Folder that processed files are to be archived.
     *
     * @var string
     */
    protected $archiveDirectory = 'archive';

    /**
     * File types to process.
     *
     * @var array
     */
    protected $fileTypes = ['job-hdr', 'job-line', 'job-col', 'job-del', 'rec-chg', 'rec-cost', 'doc-adds', 'rec-cont'];

    /**
     * Field to insert / update upon.
     *
     * @var string
     */
    protected $keyFields = [
        'job-hdr' => ['job_id'],
        'job-line' => ['job_id', 'line_no'],
        'job-col' => ['job_id', 'col_no'],
        'job-del' => ['job_id', 'del_no'],
        'rec-chg' => ['rec_id', 'line_no', 'charge_type'],
        'rec-cost' => ['rec_id', 'line_no', 'charge_type'],
        'rec-cont' => ['rec_id', 'line_no', 'record_link'],
        'doc-adds' => ['job_id', 'line_no', 'address_type'],
    ];

    /**
     * Current file type being processed.
     *
     * @var string
     */
    protected $fileType;

    /**
     * Table to update.
     *
     * @var type
     */
    protected $table;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $month = $this->option('reprocess-month');

        // Expects month e.g. 05 for May
        if (strlen($month) == 2) {
            $this->line('Moving files for the month '.$month.' for reprocessing');
            $this->moveFilesForReprocessing($month);
        }

        // Check for large number of files to processs and send warning email if required
        $this->checkDirectory();

        if ($handle = opendir($this->directory)) {
            while (false !== ($file = readdir($handle))) {
                if (! is_dir($file) && stristr($file, '.dat') && ! stristr($file, 'filepart')) {
                    if (file_exists($this->directory.$file)) {
                        $this->processFile($file);
                        $this->archiveFile($file);
                    } else {
                        Mail::to('it@antrim.ifsgroup.com')->send(new \App\Mail\GenericError('Import Multifreight Files: File not found', false, false, $this->directory.$file));
                    }
                }
            }

            closedir($handle);
        }

        // Delete old archive directories
        $this->deleteArchives();

        $this->info('Finished');
    }

    /**
     * Sets the file type and table.
     *
     * @param type $filename
     * @return bool
     */
    protected function setFileType($filename)
    {
        foreach ($this->fileTypes as $type) {
            if (stristr($filename, $type)) {
                $this->fileType = $type;

                // Instantiate corresponding model
                $className = "\App\Multifreight\\".ucfirst(Str::camel($this->fileType));

                $this->table = new $className();

                // Set an array of field names by reading the table schema
                $this->fields = DB::connection('multifreight')->getSchemaBuilder()->getColumnListing(str_replace('-', '_', $this->fileType));

                // Remove unwanted fields
                $this->fields = array_diff($this->fields, ['id', 'created_at', 'updated_at']);

                $this->info($className);

                return true;
            }
        }

        $this->error("Ignoring $filename");

        return false;
    }

    /**
     * Read one line at a time and create an array of field names and values.
     *
     * @param array $data
     *
     * @return array
     */
    private function assignFieldNames($data)
    {
        $i = 0;
        foreach ($this->fields as $field) {
            $row[$field] = (isset($data[$i]) && $data[$i] != '?') ? trim($data[$i]) : null;

            // Set the dirty flag
            if ($field == 'dirty') {
                $row[$field] = 1;
            }

            // Created Date
            if ($field == 'entry_created') {
                $row[$field] = date_create_from_format('d/m/y', $row[$field]);
            }

            // Created Date
            if ($field == 'entry_lodged') {
                $row[$field] = date_create_from_format('d/m/y', $row[$field]);
            }

            // Parse date string
            if (! empty($row[$field]) && stristr($field, 'date')) {
                $row[$field] = date_create_from_format('d/m/y', $row[$field]);
            }

            $i++;
        }

        return $row;
    }

    /**
     * Read the file contents and insert records.
     *
     * @param type $file
     */
    private function processFile($file)
    {
        $this->info("Processing file $file");

        if ($this->setFileType($file) && ($handle = fopen($this->directory.$file, 'r')) !== false) {
            $count = 0;

            while (($data = fgetcsv($handle, 2000, ' ', '"')) !== false) {
                $row = $this->assignFieldNames($data);

                $this->line("Processing row $count");

                switch (count($this->keyFields[$this->fileType])) {

                    case 1:

                        if (!empty($row['job_id'])) {
                            $this->table::firstOrCreate([
                                $this->keyFields[$this->fileType][0] => $row[$this->keyFields[$this->fileType][0]],
                            ])->update($row);
                        } else {
                            //  Mail::to('dshannon@antrim.ifsgroup.com')->send(new \App\Mail\GenericError('Import Multifreight Files: job_id is null', $this->directory.$file));
                        }

                        break;

                    case 2:
                        $this->table::firstOrCreate([
                            $this->keyFields[$this->fileType][0] => $row[$this->keyFields[$this->fileType][0]],
                            $this->keyFields[$this->fileType][1] => $row[$this->keyFields[$this->fileType][1]],
                        ])->update($row);

                        break;

                    case 3:
                        $this->table::firstOrCreate([
                            $this->keyFields[$this->fileType][0] => $row[$this->keyFields[$this->fileType][0]],
                            $this->keyFields[$this->fileType][1] => $row[$this->keyFields[$this->fileType][1]],
                            $this->keyFields[$this->fileType][2] => $row[$this->keyFields[$this->fileType][2]],
                        ])->update($row);

                        break;
                }

                $count++;
            }

            fclose($handle);
        }
    }

    /**
     * Move file to a archive directory (by month).
     *
     * @param string $file
     * @return void
     */
    public function archiveFile($file)
    {
        $this->info("Archiving file $file");

        // Extract the date from the filename
        $pos2 = strpos($file, '-', strpos($file, '-') + strlen('-'));
        $month = substr($file, $pos2 + 5, 2);

        $directory = $this->directory.$this->archiveDirectory.'/'.$month;

        // Make an archive directory for today's date if it doesn't exist
        if (! is_dir($directory)) {
            mkdir($directory, 0777, true);
        }

        $originalFile = $this->directory.$file;
        $archiveFile = $directory.'/'.$file;

        $this->info("Moving $originalFile to archive");

        if (! file_exists($originalFile)) {
            $this->error("Problem archiving $originalFile  - file not found");

            return false;
        }

        // Delete the archive file if it already exists
        if (file_exists($archiveFile)) {
            unlink($archiveFile);
        }

        if (copy($originalFile, $archiveFile)) {
            unlink($originalFile);
            $this->info('File archived successfully');
        }
    }

    /**
     * Move archived files back up to the top level to be processed again.
     *
     * @param string $month
     */
    protected function moveFilesForReprocessing($month)
    {
        $archive = $this->directory.$this->archiveDirectory.'/'.$month;

        // Check that the directory exists.
        if (! is_dir($archive)) {
            $this->error("Archive directory $month not found");

            return false;
        }

        // Get an array of filenames
        $files = scandir($archive);

        // Loop through the array of filenames and rename the .dat files to top level directory
        foreach ($files as $fname) {
            if (stristr($fname, '.dat')) {
                rename($archive.'/'.$fname, $this->directory.$fname);
                $this->line("Moved $fname successfully");
            }
        }
    }

    /**
     * Delete archive directories. Files kept for 3 months.
     */
    protected function deleteArchives()
    {
        // Get monthly archive directories
        $directories = array_filter(glob($this->directory.$this->archiveDirectory.'/*'), 'is_dir');

        // Delete the oldest directory
        if (count($directories) > 3) {
            $files = glob($directories[0].'/*');
            foreach ($files as $file) {
                is_dir($file) ? removeDirectory($file) : unlink($file);
            }
            rmdir($directories[0]);

            $this->info('Removed archive directory '.$directories[0]);
        }
    }

    /**
     * Check directory for large number of files.
     */
    protected function checkDirectory()
    {
        $files = glob($this->directory.'*.dat');

        $filecount = 0;

        if ($files !== false) {
            $filecount = count($files);

            if ($filecount > 250) {
                $this->error('Sending warning: large number of files to process');

                Mail::to('it@antrim.ifsgroup.com')->send(new \App\Mail\GenericError('Import Multifreight Files: WARNING', $filecount.' files detected for processing'));
            }
        }
    }
}
